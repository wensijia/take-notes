---
title: Spring Cloud理解
date: 2025-02-08 10:18:22
tags:
  - Spring Cloud
description: Spring Cloud理解
copyright: true
---

1. 微服务是种思想，你可以近似把微服务这个思想理解成一个接口，springcloud就是这个接口的implement
2. 微服务是个什么思想呢？那就是一个服务只做一件事，功能隔离开，就像吃鸳鸯锅一样，一个格子只有一个味儿
3. springcloud作为这种思想的实现，不是一种技术，而是一组技术的组合体，下面一个个说
4. 服务拆开了，那微服务之间要互相发送信息吧，比如我是订单系统，你是发邮件给电子发票，那我们之间肯定要通信啊，我给你发个短信，你看到了就给xx用户把发票发过去。这时候就出现了MQ消息队列，MQ就是发短信，我只管发，你只管收，互相不管着
5. 但是有时候不能发短信，得打电话，比如用户下订单了，我下单系统必须要风控系统立刻告诉我这个人有没有风险，不能等。那是不是就得打电话呀，这就是rpc或者http调用，A系统调用B系统的能力，并且实时得到结果。
6. http协议是不是有很多配置啊，这些配置都不是真实数据，那消息体是不是就会膨胀的很大呀，那就慢了对不对，所以后端微服务之间需要打电话的时候，就会选rpc，协议更精简，一次传输更多真实数据
7. 问题又来了，我们服务越来越多，我怎么知道我该跟哪个服务打电话呀？这就是注册中心，服务上线的时候把自己需要的或者提供的能力告诉注册中心，由注册中心居中转接，就像电话交换机一样
8. 运维的同学站起来了，说你们不能没完没了打电话啊，我cpu内存扛不住了都。不用急，我们给打电话加一个限制，每秒只允许打n个电话，这就是服务限流
9. 运维的同学还是害怕，要是我们真有个服务电话被打停机了或者短信收不过来了（服务挂了），整个公司就完了啊，怎么办？别慌，兜底熔断策略做起来，如果接电话的服务扛不住了（达到某个阈值或者宕机了），不管如何直接给一个默认的结果，先继续跑，别让所有服务都寄。或者把短信和电话都先平移到别的系统，完全不做处理，只是先把数据接过来，这就是死信。
10. 那你又要问了，如果我们一个服务并发量上去了，一个服务实例不够了呀，要水平扩容啊，人工做的话运维压力好大，怎么办？上容器嘛，一个镜像一个服务，k8s这个管家自动给你拉起，准备好运行环境，还给你做反向代理，负载均衡
11. 哎，有同学说了，我项目正在运行，突然有个配置文件内容变了，我真不想改代码发版啊，怎么办？配置中心这不就来了吗，Apollo启动，跟你的服务开一个长连接，配置随改随更新，完全不用改代码发版，又是准点下班的一天
12. 网安的同学举手了，说我们这个后端服务的ip地址不能直接对外暴露啊，不然ddos了我死给你看。别急，统一网关这不就来了，由网关层统一接收所有请求，再由网关反向代理给真实服务嘛。这一步从设计模式上说叫前端设计模式，从网络路径上说叫外转内
13. 用户拓展的同学也有话说，我们用户用我们的系统，每个功能都要登录一下，你们搞这个微服务干嘛啊，就不能一次登陆，每个系统都认这个登陆态吗？好说好说，单点登录给你弄上，用户的token我们进缓存，用缓存锁同步用户信息
14. 运维的同学又有意见了，你们不能每次大难临头了才来找我们救火，能不能搞一套提前预警啊？也有办法，不慌，给你grafana和promethus，你想看图表算趋势看阈值，短信预警电话预警都能给你搞
15. 这时候用户组的人也有问题了，你们这些微服务用容器做高并发的，万一多个用户，在生成用户id的时候重复了怎么整？雪花算法就来了，保证你一个人一个id不重样